% Methodik und Versuchsaufbau.tex

% Definiere Variablen
% \newcommand{\Messziel}{Messziel}

% % ----------------------
% % 3. Methodik und Versuchsaufbau
% % ----------------------
% \newpage
% \chapter{Methodik und Versuchsaufbau}
% \section{Messumgebung und Hardware}
% % CPU, RAM, OS, Compiler
% \section{Implementierungsvarianten}
% % Sequenziell, parallel, Workerthreads, neue Threads
% \section{Messmethodik}
% % Vorgehensweise zur Laufzeitmessung, Datenerhebung

% \section{Messumgebung und Hardware}
% % CPU, RAM, OS, Compiler
\newcommand{\MessumgebungUndHardware}{
    Die relevanten Hardwarekomponenten werden im Anhang detailliert aufgelistet. Zusammenfassend wurden die Tests auf einem System mit einer 8-Kern-CPU durchgeführt (8 physische Kerne bzw. 16 logische Prozessoren) sowie mit 32~GB Arbeitsspeicher.
    \newline
    Als Betriebssystem kam Windows~10 in der Version~22H2 zum Einsatz. Der Code ist in der Programmiersprache \texttt{C++} implementiert und wurde mittels CMake mit dem MSVC-Compiler kompiliert. Die Ausführung der Tests erfolgte im integrierten Terminal von Visual Studio Code in einer Release-Konfiguration. Sollte hiervon abgewichen worden sein, wird dies an entsprechender Stelle gesondert angegeben.
}

% \section{Implementierungsvarianten}
% % Sequenziell, parallel, Workerthreads, neue Threads
\newcommand{\Implementierungsvarianten}{
    Es wurden folgende Implementierungsvarianten umgesetzt:
    \begin{itemize}
        \item rekursiv sequenzielle Variante,
        \item rekursive Variante mit neu erzeugten Threads bis zu einer Ebene mit einer unterstützten Thread-Anzahl von \(2^N\),
        \item Worker-Thread-Variante nach einem Work-Stealing-Ansatz mit einer unterstützten Thread-Anzahl von \(N\), bei Quicksort als iterative Version umgesetzt.
    \end{itemize}
    Für die Variante der tiefenbasierten Thread-Erzeugung kann man von folgender Gleichung ausgehen:
    \begin{flalign*}
        e         & = \log_2(\text{Thread-Anzahl})                                                                                      &  & \\
        T(n,e)    & = n \cdot 2 \left( 1 - \frac{1}{2^e} \right) + \frac{n}{2^e} \cdot \log_2\left(\frac{n}{2^e}\right) + \frac{n}{2^e} &  & \\
        O(T(n,e)) & = O\left(n + \frac{n}{2^e} \cdot \log_2(n)\right)                                                                   &  &
    \end{flalign*}
    Man muss jedoch auch beachten, dass für Quicksort im Worst-Case weiterhin \(O(n^2)\) gilt. Außerdem kann man nicht mehr Ebenen parallelisieren, als vorhanden sind, was bedeutet, dass \(e_{\max} = log_2(n)\) ist.
    Für die Work-Stealing-Variante lässt sich keine exakte Laufzeit vorhersagen, sondern nur abschätzen. Man kann jedoch gerundet von derselben Laufzeit ausgehen wie bei der tiefenbasierten Thread-Erzeugungs-Variante.
}

% \section{Messmethodik}
% % Vorgehensweise zur Laufzeitmessung, Datenerhebung
\newcommand{\Messmethodik}{
    Zur Laufzeitmessung wurden zufällig erzeugte Listen verwendet, die stets mit demselben Seed initialisiert wurden. Dadurch sind alle Messungen reproduzierbar und miteinander vergleichbar.
    \newline
    Die Zeitmessung erfolgte mithilfe der Bibliothek \texttt{chrono}. Die gemessenen Zeiten besitzen eine Auflösung von 100\,ns und wurden entsprechend in Nanosekunden gespeichert sowie in den Diagrammen dargestellt. Zur Einordnung gilt:
    \(1\,\text{s} = 10^3\,\text{ms} = 10^9\,\text{ns}\).
    \newline
    Die Messung begann unmittelbar vor dem Aufruf des zu untersuchenden Sortieralgorithmus und endete direkt nach dessen Abschluss. Die Zeit für die Initialisierung der Testlisten wurde dabei selbstverständlich nicht mitgemessen.
    \newline
    Nach den meisten Messungen wurde überprüft, ob die resultierende Liste korrekt sortiert ist, um die funktionale Korrektheit der Implementierung sicherzustellen.
    \newline
    Für die Darstellung der theoretischen Laufzeiten in den Diagrammen gehe ich der Übersicht halber von einer direkten 1:1-Zuordnung von Arraygröße zu Dauer in ns aus. Diese Annahme ist jedoch stark vereinfacht, da sie nicht garantiert werden kann. Die erwarteten Werte sollten daher stets kritisch betrachtet werden.
}
\documentclass[10pt, ngerman]{beamer}

\usetheme{Madrid} 

% ----------------------
% Pakete
% ----------------------
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{amsmath, amssymb}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{geometry}
\usepackage{listings}
\usepackage{float}
\usepackage{mathtools} 
\usepackage{tikz}
\usepackage{pgfplots}
\usetikzlibrary{positioning, arrows.meta}
\pgfplotsset{compat=1.18}

\hypersetup{
    pdfborder={0 0 0},    % Entfernt alle Rahmen um Links
}

% ----------------------
% C++ Code Settings
% ----------------------
\lstset{
    language=C++,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny,
    stepnumber=1,
    numbersep=5pt,
    frame=single,
    breaklines=true,
    showstringspaces=false
}

\title[Skalierbarkeit paralleles Sortieren]{Untersuchung der Skalierbarkeit von parallelem Sortieren auf einem Multicore-Prozessor}
\subtitle{Verteidigung der Bachelorarbeit}
\author{Leon Zoerner}
\institute{Informatik}
\date{\today}

\begin{document}

\begin{frame}
    \titlepage
\end{frame}

\begin{frame}{Agenda}
    \tableofcontents
\end{frame}

\section{Formeln}
\begin{frame}{Formeln: Mergesort}
    \begin{flalign*}
        T(n)    & = m_1 + m_2 + n                                                                                                             & \\
        T(n)    & = T \left ( \left \lfloor \frac{n}{2} \right \rfloor \right) + T \left ( \left \lceil \frac{n}{2} \right \rceil \right) + n & \\
        T(n)    & = 2 \cdot T \left( \frac{n}{2} \right) + n,                                                                                 & \\
        T(n)    & = n \cdot \log_2(n) + n,                                                                                                    & \\
        O(T(n)) & = O(n \log n).                                                                                                              &
    \end{flalign*}
\end{frame}

\begin{frame}{Formeln: Quicksort}
    \textbf{Best-Case} von Quicksort:
    \begin{flalign*}
        T(n)    & = q1 + q2 + n                                                                                                               & \\
        T(n)    & = T \left ( \left \lfloor \frac{n}{2} \right \rfloor \right) + T \left ( \left \lceil \frac{n}{2} \right \rceil \right) + n & \\
        T(n)    & = 2 \cdot T \left( \frac{n}{2} \right) + n,                                                                                 & \\
        T(n)    & = n \cdot \log_2(n) + n,                                                                                                    & \\
        O(T(n)) & = O(n \log n).                                                                                                              &
    \end{flalign*}
\end{frame}

\begin{frame}{Formeln: Quicksort}
    Der \textbf{Worst-Case} von Quicksort ist:
    \begin{flalign*}
        T(n)    & = q_1 + q_2 + n                      & \\
        T(n)    & = T(n-1) + 1 + n,                    & \\
        T(n)    & = \frac{1}{2} \cdot ( n^2 + n ) + n, & \\
        O(T(n)) & = O(n^2).                            &
    \end{flalign*}

    Der \textbf{heuristisch betrachtete Average-Case} von Quicksort ist:
    \begin{flalign*}
        T(n)    & = q_1 + q_2 + n                                                                                                                                 & \\
        q_1     & = T\left( \frac{1 + \dots + (n-1)}{n-1} \right) = T\left( n \cdot \frac{n-1}{2} \cdot \frac{1}{n-1} \right) = T\left( \frac{n}{2} \right) = q_2 & \\
        T(n)    & = 2 \cdot T\left( \frac{n}{2} \right) + n                                                                                                       & \\
        T(n)    & = n \cdot \log_2(n) + n                                                                                                                         & \\
        O(T(n)) & = O(n \log n).                                                                                                                                  &
    \end{flalign*}
\end{frame}

\begin{frame}{Formeln: parallel Mergesort}
    \begin{flalign*}
        p         & = \text{Thread-Anzahl}                                                                               &  & \\
        e         & = \log_2(p)                                                                                          &  & \\
        T(n,e)    & = \begin{cases}
                          2 \cdot T\left(\frac{n}{2}, 0\right) + n   & \text{, wenn } e = 0 \\
                          1 \cdot T\left(\frac{n}{2}, e-1\right) + n & \text{, wenn } e > 0
                      \end{cases}                                 &  &                                       \\
        T(n,p)    & = 2n \left( 1 - \frac{1}{p} \right) + \frac{n}{p} \cdot \log_2\left(\frac{n}{p}\right) + \frac{n}{p} &  & \\
        O(T(n,p)) & = O\left( \frac{n}{p} \cdot \log_2(n) + n \right)                                                    &  & \\
        e_{\max}  & = \log_2(n)                                                                                          &  & \\
        p_{\max}  & = n
    \end{flalign*}
\end{frame}

\begin{frame}{Formeln: parallel Quicksort}
    Der \textbf{Best-Case} und \textbf{heuristisch betrachtete Average-Case} von Quicksort ist:
    \begin{flalign*}
        p         & = \text{Thread-Anzahl}                                                                               &  & \\
        e         & = \log_2(p)                                                                                          &  & \\
        T(n,e)    & = \begin{cases}
                          2 \cdot T\left(\frac{n}{2}, 0\right) + n   & \text{, wenn } e = 0 \\
                          1 \cdot T\left(\frac{n}{2}, e-1\right) + n & \text{, wenn } e > 0
                      \end{cases}                                 &  &                                       \\
        T(n,p)    & = 2n \left( 1 - \frac{1}{p} \right) + \frac{n}{p} \cdot \log_2\left(\frac{n}{p}\right) + \frac{n}{p} &  & \\
        O(T(n,p)) & = O\left( \frac{n}{p} \cdot \log_2(n) + n \right)                                                    &  & \\
        e_{\max}  & = \log_2(n)                                                                                          &  & \\
        p_{\max}  & = n
    \end{flalign*}
\end{frame}

\begin{frame}{Formeln: parallel Quicksort}
    Der \textbf{Worst-Case} von Quicksort (Worker-Thread-Variante) bei $p > 1$ ist:
    \begin{flalign*}
        T(n)    & = q_2 + n,                       & \\
        T(n)    & = T(n-1) + n,                    & \\
        T(n)    & = \frac{1}{2} \cdot ( n^2 + n ), & \\
        O(T(n)) & = O(n^2).                        &
    \end{flalign*}
\end{frame}

\begin{frame}{Formeln: Einheiten und Skalierung}
    \begingroup
    \setlength{\belowdisplayskip}{-5pt}
    \begin{flalign*}
        x \cdot T(n) & = 2 \cdot T \left( \frac{n}{2} \right) + x \cdot n & \\
        x \cdot T(n) & =  x \cdot n \cdot \log_2(n) + x \cdot n           & \\
        x \cdot T(n) & = x \cdot \left( n \cdot \log_2(n) + n \right)     & \\
    \end{flalign*}
    \endgroup
    Aufgrund von Overheads wie z.\,B. erhöhte Speicherlatenzen durch Cache-Misses:
    \begingroup
    \setlength{\belowdisplayskip}{-10pt}
    \begin{flalign*}
        x      & = f(n,p)     & \\
        f(n,p) & \le f(n+1,p) & \\
        f(n,p) & \le f(n,p+1) & \\
    \end{flalign*}
    \endgroup
    \includegraphics[width=1\textwidth]{Abbildungen/SpeicherlatenzenDiagramm.jpg}
\end{frame}

\section{Einleitung}
\begin{frame}{Motivation \& Zielsetzung}
    % Hier Kernpunkte aus \Motivation und \ZielsetzungUndForschungsfrage
\end{frame}

\section{Theoretische Grundlagen}
\begin{frame}{Grundlagen der Parallelisierung}
    % Hier Kernpunkte aus \SortieralgorithmenQuicksortMergesort
    % Und \GrundlagenDerParallelisierung
\end{frame}

\section{Methodik und Versuchsaufbau}
\begin{frame}{Messumgebung und Implementierung}
    % Hier Details aus \MessumgebungUndHardware
\end{frame}

\begin{frame}[fragile]{Implementierungsvarianten Code}
    % [fragile] ist nötig für Listings auf Folien
\end{frame}

\section{Ergebnisse und Analyse}
\begin{frame}{Laufzeitmessungen (sequenziell)}
    % Platz für Diagramme aus \GrundlegendeLaufzeitenAbhaengigVonDerArraygroesseDiagramm
\end{frame}

\begin{frame}{Analyse der Threading-Methoden}
    % Vergleich Workerthreads vs. Tiefenbasierte Erzeugung
\end{frame}

\section{Diskussion und Fazit}
\begin{frame}{Beantwortung der Forschungsfrage}
    % Kernpunkte aus \BeantwortungDerForschungsfrage
\end{frame}

\begin{frame}{Zusammenfassung und Ausblick}
    % Kernpunkte aus \Zusammenfassung und \Ausblick
\end{frame}

\begin{frame}
    \centering
    \Huge Vielen Dank für Ihre Aufmerksamkeit!\\
    \vspace{1cm}
    \large Fragen und Diskussion
\end{frame}

\end{document}

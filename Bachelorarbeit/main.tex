\documentclass[10pt, ngerman]{beamer}

\usetheme{Madrid} 

% ----------------------
% Pakete
% ----------------------
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{amsmath, amssymb}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{geometry}
\usepackage{listings}
\usepackage{float}
\usepackage{mathtools} 
\usepackage{tikz}
\usepackage{pgfplots}
\usetikzlibrary{positioning, arrows.meta}
\pgfplotsset{compat=1.18}

\hypersetup{
    pdfborder={0 0 0},    % Entfernt alle Rahmen um Links
}

% ----------------------
% C++ Code Settings
% ----------------------
\lstset{
    language=C++,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny,
    stepnumber=1,
    numbersep=5pt,
    frame=single,
    breaklines=true,
    showstringspaces=false
}

\title[Skalierbarkeit paralleles Sortieren]{Untersuchung der Skalierbarkeit von parallelem Sortieren auf einem Multicore-Prozessor}
\subtitle{Verteidigung der Bachelorarbeit}
\author{Leon Zoerner}
\institute{Informatik}
\date{\today}

\include{Kapitel/Kapitel}

\begin{document}

\begin{frame}
    \titlepage
\end{frame}

\begin{frame}{Agenda}
    \tableofcontents
\end{frame}

\section{Einleitung}
\begin{frame}{Einleitung: Motivation}
    \textbf{Motivation:}
    \Motivation
\end{frame}

\begin{frame}{Einleitung: Zielsetzung und Forschungsfrage}
    \textbf{Zielsetzung und Forschungsfrage:}
    \ZielsetzungUndForschungsfrage
\end{frame}

\section{Theoretische Grundlagen}
\begin{frame}{Theoretische Grundlagen}
    \textbf{Hinweis zur mathematischen Darstellung}
    Die in dieser Arbeit genutzten mathematischen Beschreibungen und Formeln beziehen sich durchgehend auf die konkret implementierten Programmstrukturen und können daher von allgemeinen Standardformeln abweichen.
\end{frame}

\begin{frame}{Sortieralgorithmen: Quicksort und Mergesort}
    Sowohl \textbf{Quicksort} als auch \textbf{Mergesort} basieren auf dem \emph{Teile-und-Herrsche}-Prinzip und sind rekursive Sortieralgorithmen. Dabei wird das zu sortierende Array wiederholt in kleinere Teilprobleme zerlegt, die unabhängig voneinander verarbeitet werden.
\end{frame}

\begin{frame}{Sortieralgorithmen: Mergesort}
    Das Grundprinzip von \textbf{Mergesort} besteht darin, zwei bereits sortierte Teilarrays zu einem sortierten Array zusammenzuführen. In dieser Arbeit wird das unsortierte Eingabearray rekursiv in zwei möglichst gleich große Hälften geteilt, bis jedes Teilarray nur noch aus einem einzelnen Element besteht. Da ein Array mit einem Element per Definition sortiert ist, beginnt anschließend der sogenannte \emph{Merge-Schritt (Mischen)}. In diesem Schritt werden jeweils zwei sortierte Teilarrays zu einem sortierten Gesamtergebnis zusammengeführt.
    \newline
    Hierfür werden beide Teilarrays mit einer Gesamtlänge von \(n\) Elementen sequenziell durchlaufen und die Elemente verglichen.
    Der Aufwand pro Merge-Schritt entspricht dabei \(n\) Vergleichen, da jedes Element genau einmal betrachtet wird, sowie \(2n\) Lese- und Schreibzugriffen, da die Elemente temporär in ein neues Array der Größe \(n\) geschrieben und von dort wieder gelesen werden müssen.
\end{frame}

\begin{frame}[fragile]{Sortieralgorithmen: Mergesort}

    \begin{lstlisting}[language=C++, basicstyle=\ttfamily\small]
    void Mergesort::mergesort(int *liste, const int links, const int rechts) {
        int laenge = rechts - links + 1;
        if (laenge > 1) {
            int mitte = links + ((rechts - links) / 2);
            mergesort(liste, links, mitte);      // A
            mergesort(liste, mitte + 1, rechts); // B
            mischen(liste, links, mitte, rechts, laenge);
        }
    }
    \end{lstlisting}

\end{frame}

\begin{frame}[fragile]{Sortieralgorithmen: Mergesort}

    \begin{lstlisting}[language=C++, basicstyle=\ttfamily\small]
    void Mergesort::mischen(int *liste, int links, const int mitte, const int rechts, const int lange) {
        int *listeB = new int[lange];
    
        // Kopiere nach listeB
        for (int i = links; i < mitte + 1; i++) {
            listeB[i - links] = liste[i];
        }
        for (int i = mitte + 1; i < rechts + 1; i++) {
            listeB[lange - 1 + mitte + 1 - i] = liste[i];
        }
    
        // Sortiere liste
        int i = 0;         // links
        int j = lange - 1; // rechts
        int k = links;     // links
        while (i < j) {
            if (listeB[i] < listeB[j]) {
                liste[k] = listeB[i];
                i++;
            } else {
                liste[k] = listeB[j];
                j--;
            }
            k++;
        }
        liste[rechts] = listeB[i];
    
        delete[] listeB;
    };    
    \end{lstlisting}

\end{frame}

\begin{frame}[fragile]{Sortieralgorithmen: Mergesort}

    \begin{lstlisting}[language=C++, basicstyle=\ttfamily\small]
        ...
        // Sortiere liste
        int i = 0;         // links
        int j = lange - 1; // rechts
        int k = links;     // links
        while (i < j) {
            if (listeB[i] < listeB[j]) {
                liste[k] = listeB[i];
                i++;
            } else {
                liste[k] = listeB[j];
                j--;
            }
            k++;
        }
        liste[rechts] = listeB[i];
        delete[] listeB;
    };    
    \end{lstlisting}

\end{frame}

\begin{frame}{Sortieralgorithmen: Mergesort}
    \begin{flalign*}
        T(n)    & = m_1 + m_2 + n                                                                                                             & \\
        T(n)    & = T \left ( \left \lfloor \frac{n}{2} \right \rfloor \right) + T \left ( \left \lceil \frac{n}{2} \right \rceil \right) + n & \\
        T(n)    & = 2 \cdot T \left( \frac{n}{2} \right) + n,                                                                                 & \\
        T(n)    & = n \cdot \log_2(n) + n,                                                                                                    & \\
        O(T(n)) & = O(n \log n).                                                                                                              &
    \end{flalign*}
\end{frame}


\begin{frame}{Sortieralgorithmen: Mergesort}
    Balancierter Binärbaum für $n = 16$
    \newline
    \newline
    \BalancierterBinaerbaumNSechzehn
\end{frame}

\begin{frame}{Sortieralgorithmen: Quicksort}
    \textbf{Quicksort} ist im Grundaufbau ähnlich strukturiert, unterscheidet sich jedoch wesentlich im Ablauf. Die Liste wird nicht zwingend in zwei gleich große Hälften geteilt. Stattdessen wird zunächst ein sogenanntes \emph{Pivot-Element} gewählt, anhand dessen die Liste in einen kleineren und einen größeren Teil partitioniert wird. Dieser Partitionierungsschritt erfolgt vor den rekursiven Selbstaufrufen.
    Beim Partitionieren wird die Liste so umsortiert, dass alle Elemente, die kleiner als das Pivotelement sind, links davon stehen und alle Elemente, die größer sind, rechts davon stehen. Dabei werden die Elemente auf beiden Seiten entsprechend getauscht.
\end{frame}

\begin{frame}[fragile]{Sortieralgorithmen: Quicksort}

    \begin{lstlisting}[language=C++, basicstyle=\ttfamily\small]
    void Quicksort::quicksort(int *liste, const int links, const int rechts) {
        if (links < rechts) {
            int ml, mr;
            partitioniere(liste, links, rechts, ml, mr);
            quicksort(liste, links, ml);
            quicksort(liste, mr, rechts);
        }
    };
    \end{lstlisting}

\end{frame}

\begin{frame}[fragile]{Sortieralgorithmen: Quicksort}

    \begin{lstlisting}[language=C++, basicstyle=\ttfamily\small]
    void Quicksort::partitioniere(int *liste, const int links, const int rechts, int &ml, int &mr) {
        int i = links;
        int j = rechts;
        int mitte = links + ((rechts - links) / 2);
        int p = liste[mitte];
        while (i <= j) {
            while (liste[i] < p) {
                i++;
            }
            while (liste[j] > p) {
                j--;
            }
            if (i <= j) {
                vertausche(liste, i, j);
                i++;
                j--;
            }
        };
        ml = j; mr = i;
    };
    \end{lstlisting}

\end{frame}

\begin{frame}[fragile]{Sortieralgorithmen: Quicksort}

    \begin{lstlisting}[language=C++, basicstyle=\ttfamily\small]
    void Quicksort::vertausche(int *liste, const int a, const int b) {
        int temp = liste[a];
        liste[a] = liste[b];
        liste[b] = temp;
    };
    \end{lstlisting}

\end{frame}

\begin{frame}{Sortieralgorithmen: Quicksort}
    \textbf{Best-Case} von Quicksort:
    \begin{flalign*}
        T(n)    & = q_1 + q_2 + n                                                                                                             & \\
        T(n)    & = T \left ( \left \lfloor \frac{n}{2} \right \rfloor \right) + T \left ( \left \lceil \frac{n}{2} \right \rceil \right) + n & \\
        T(n)    & = 2 \cdot T \left( \frac{n}{2} \right) + n,                                                                                 & \\
        T(n)    & = n \cdot \log_2(n) + n,                                                                                                    & \\
        O(T(n)) & = O(n \log n).                                                                                                              &
    \end{flalign*}
\end{frame}

\begin{frame}{Sortieralgorithmen: Quicksort}
    Balancierter Binärbaum für $n = 16$
    \newline
    \newline
    \BalancierterBinaerbaumNSechzehn
\end{frame}

\begin{frame}{Sortieralgorithmen: Quicksort}
    Der \textbf{Worst-Case} von Quicksort ist:
    \begin{flalign*}
        T(n)    & = q_1 + q_2 + n                      & \\
        T(n)    & = T(n-1) + 1 + n,                    & \\
        T(n)    & = \frac{1}{2} \cdot ( n^2 + n ) + n, & \\
        O(T(n)) & = O(n^2).                            &
    \end{flalign*}

    Der \textbf{heuristisch betrachtete Average-Case} von Quicksort ist:
    \begin{flalign*}
        T(n)    & = q_1 + q_2 + n                                                                                                                                 & \\
        q_1     & = T\left( \frac{1 + \dots + (n-1)}{n-1} \right) = T\left( n \cdot \frac{n-1}{2} \cdot \frac{1}{n-1} \right) = T\left( \frac{n}{2} \right) = q_2 & \\
        T(n)    & = 2 \cdot T\left( \frac{n}{2} \right) + n                                                                                                       & \\
        T(n)    & = n \cdot \log_2(n) + n                                                                                                                         & \\
        O(T(n)) & = O(n \log n).                                                                                                                                  &
    \end{flalign*}
\end{frame}

\begin{frame}{Sortieralgorithmen: Quicksort}
    Maximal unbalancierter Binärbaum für $n = 4$ \textbf{Worst-Case}:
    \newline
    \newline
    \QuicksortWorstCaseBaum
\end{frame}


\section{Methodik und Versuchsaufbau}
\begin{frame}{Messumgebung und Implementierung}
    % Hier Details aus \MessumgebungUndHardware
\end{frame}

\begin{frame}[fragile]{Implementierungsvarianten Code}
    % [fragile] ist nötig für Listings auf Folien
\end{frame}

\section{Ergebnisse und Analyse}
\begin{frame}{Laufzeitmessungen (sequenziell)}
    % Platz für Diagramme aus \GrundlegendeLaufzeitenAbhaengigVonDerArraygroesseDiagramm
\end{frame}

\begin{frame}{Analyse der Threading-Methoden}
    % Vergleich Workerthreads vs. Tiefenbasierte Erzeugung
\end{frame}

\section{Diskussion und Fazit}
\begin{frame}{Beantwortung der Forschungsfrage}
    % Kernpunkte aus \BeantwortungDerForschungsfrage
\end{frame}

\begin{frame}{Zusammenfassung und Ausblick}
    % Kernpunkte aus \Zusammenfassung und \Ausblick
\end{frame}

\begin{frame}
    \centering
    \Huge Vielen Dank für Ihre Aufmerksamkeit!\\
    \vspace{1cm}
    \large Fragen und Diskussion
\end{frame}

\alleFolien

\end{document}
